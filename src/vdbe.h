/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Header file for the Virtual DataBase Engine (VDBE)
**
** This header defines the interface to the virtual database engine
** or VDBE.  The VDBE implements an abstract machine that runs a
** simple program to access and modify the underlying database.
**
** SQLite 虚拟数据库引擎 (VDBE) 接口头文件
**
** 本头文件定义了虚拟数据库引擎（VDBE）的接口。VDBE 实现了一个抽象机器，
** 运行简单的程序来访问和修改底层数据库。
**
** VDBE 架构概述：
**
** 1. 虚拟机设计：
**    - 基于栈的虚拟机架构，执行字节码指令序列
**    - 每条 SQL 语句被编译成 VDBE 字节码程序
**    - 支持过程化控制流（跳转、条件分支、子程序调用）
**
** 2. 指令系统：
**    - 固定长度的指令格式，包含操作码和最多 5 个操作数
**    - 支持算术、逻辑、比较、控制流、I/O 等各类操作
**    - 操作数可以是寄存器、常量、指针或复杂数据结构
**
** 3. 内存模型：
**    - 寄存器文件：固定数量的内存寄存器用于存储临时数据
**    - 栈结构：用于函数调用和表达式求值
**    - 游标管理：用于遍历 B-Tree 和访问表数据
**
** 4. 执行模型：
**    - 解释执行：逐条解释并执行字节码指令
**    - 即时编译 (JIT)：某些版本支持将字节码编译为本地机器码
**    - 事务集成：与 B-Tree 事务系统紧密集成
**
** 5. 调试和优化：
**    - 解释器接口：.explain 命令显示字节码程序
**    - 性能分析：指令级执行统计和性能分析
**    - 覆盖率测试：测试工具支持代码覆盖率分析
**
** 主要组件：
** - Vdbe：虚拟机主结构，包含执行状态和资源
** - VdbeOp：虚拟机指令结构，定义操作码和操作数
** - SubProgram：子程序结构，用于触发器和存储过程
** - Mem：内存值结构，表示各种数据类型
**
** 接口功能：
** - 字节码生成：从 SQL 语句生成 VDBE 程序
** - 程序执行：解释执行字节码指令序列
** - 状态管理：管理虚拟机的运行状态和生命周期
** - 资源管理：分配和释放虚拟机相关资源
*/
#ifndef SQLITE_VDBE_H
#define SQLITE_VDBE_H
#include <stdio.h>

/*
** A single VDBE is an opaque structure named "Vdbe".  Only routines
** in the source file sqliteVdbe.c are allowed to see the insides
** of this structure.
**
** 单个 VDBE 是一个名为 "Vdbe" 的不透明结构体。
** 只有 sqliteVdbe.c 源文件中的例程允许查看此结构的内部。
**
** Vdbe 结构体设计原则：
** - 信息隐藏：封装虚拟机的内部状态和实现细节
** - 接口隔离：通过明确的 API 函数访问 VDBE 功能
** - 模块化设计：将虚拟机实现限制在单一源文件中
** - 维护性：减少内部实现变更对外部模块的影响
**
** Vdbe 主要包含：
** - 执行状态：程序计数器、栈指针、错误状态等
** - 内存资源：寄存器数组、内存池、游标集合
** - 程序代码：字节码指令序列和相关信息
** - 执行环境：数据库连接、事务上下文、回调函数
*/
typedef struct Vdbe Vdbe;  /* 虚拟机主结构体 - 不透明类型 */

/*
** The names of the following types declared in vdbeInt.h are required
** for the VdbeOp definition.
**
** 以下类型名称在 vdbeInt.h 中声明，为 VdbeOp 定义所需要。
**
** 这些是 VDBE 子系统的核心数据结构：
**
** Mem (sqlite3_value): 内存值结构
**    - 表示 SQLite 中的任意数据值
**    - 支持所有 SQLite 数据类型：NULL、INTEGER、REAL、TEXT、BLOB
**    - 包含值、类型、编码和存储管理信息
**
** SubProgram: 子程序结构
**    - 用于存储触发器程序和存储过程
**    - 包含独立的字节码指令序列
**    - 支持嵌套调用和递归执行
**
** SubrtnSig: 子程序签名结构
**    - 用于标识和管理可重用的子程序
**    - 包含子程序的元数据和调用信息
**    - 支持子程序缓存和性能优化
*/
typedef struct sqlite3_value Mem;        /* 内存值结构 - 表示各种数据类型 */
typedef struct SubProgram SubProgram;    /* 子程序结构 - 用于触发器和存储过程 */
typedef struct SubrtnSig SubrtnSig;      /* 子程序签名结构 - 子程序标识和元数据 */

/*
** A signature for a reusable subroutine that materializes the RHS of
** an IN operator.
**
** 用于物化 IN 操作符右侧的可重用子程序签名结构。
**
** 此结构体用于优化 IN 操作符的执行性能。当遇到形如 "x IN (SELECT ...)"
** 的查询时，右侧的 SELECT 语句可以预先生成结果集并缓存在临时表中，
** 避免重复执行相同的子查询。
**
** IN 操作符优化机制：
** 1. 子程序缓存：将相同的子查询编译为可重用的子程序
** 2. 结果集物化：将子查询结果存储在临时表中
** 3. 多次复用：同一子查询的结果可以被多次引用
** 4. 内存管理：自动管理临时表的生命周期
**
** 性能优势：
** - 减少子查询的重复执行
** - 提高复杂查询的执行效率
** - 支持查询计划优化器更好地选择执行策略
*/
struct SubrtnSig {
  int selId;          /* SELECT-id for the SELECT statement on the RHS - 右侧 SELECT 语句的 ID */
  u8 bComplete;       /* True if fully coded and available for reusable - 如果完全编码且可重用则为真 */
  char *zAff;         /* Affinity of the overall IN expression - 整体 IN 表达式的亲和性 */
  int iTable;         /* Ephemeral table generated by the subroutine - 子程序生成的临时表 */
  int iAddr;          /* Subroutine entry address - 子程序入口地址 */
  int regReturn;      /* Register used to hold return address - 用于保存返回地址的寄存器 */
};

/*
** A single instruction of the virtual machine has an opcode
** and as many as three operands.  The instruction is recorded
** as an instance of the following structure:
**
** 虚拟机单条指令包含一个操作码和最多三个操作数。
** 指令被记录为以下结构体的实例：
**
** VDBE 指令设计原则：
**
** 1. 固定长度指令：所有指令具有相同的内存布局，便于执行和优化
** 2. 多操作数设计：支持最多 5 个操作数 (p1, p2, p3, p4, p5)
** 3. 类型灵活性：操作数可以是寄存器、常量、指针或复杂结构
** 4. 扩展性：p4 联合体支持多种数据类型，p5 用于标志位
**
** 指令执行流程：
** 1. 取指：从程序数组中获取下一条指令
** 2. 译码：解析操作码和操作数类型
** 3. 执行：根据操作码调用相应的执行函数
** 4. 更新：修改程序计数器和虚拟机状态
**
** 操作数说明：
** - p1: 主要操作数，通常是寄存器编号或常量值
** - p2: 次要操作数，常用于跳转目标或循环计数
** - p3: 第三操作数，用于特殊目的的参数传递
** - p4: 联合体操作数，支持复杂数据类型的传递
** - p5: 标志位操作数，用于控制指令的执行选项
**
** 优化特性：
** - 指令重排：优化器可以重新排列指令序列提高效率
** - 常量折叠：编译时计算常量表达式
** - 死代码消除：移除不会执行的指令
** - 内联优化：将简单操作内联到指令执行中
*/
struct VdbeOp {
  u8 opcode;          /* What operation to perform - 要执行的操作码 */
  signed char p4type; /* One of the P4_xxx constants for p4 - p4 的类型常量之一 */
  u16 p5;             /* Fifth parameter is an unsigned 16-bit integer - 第五个参数，16位无符号整数 */
  int p1;             /* First operand - 第一个操作数 */
  int p2;             /* Second parameter (often the jump destination) - 第二个参数（通常是跳转目标） */
  int p3;             /* The third parameter - 第三个参数 */
  union p4union {     /* fourth parameter - 第四个参数，联合体支持多种类型 */
    int i;                 /* Integer value if p4type==P4_INT32 - 当 p4type==P4_INT32 时的整数值 */
    void *p;               /* Generic pointer - 通用指针，适用于多种用途 */
    char *z;               /* Pointer to data for string (char array) types - 字符串数据的指针 */
    i64 *pI64;             /* Used when p4type is P4_INT64 - 当 p4type 是 P4_INT64 时使用 */
    double *pReal;         /* Used when p4type is P4_REAL - 当 p4type 是 P4_REAL 时使用 */
    FuncDef *pFunc;        /* Used when p4type is P4_FUNCDEF - 当 p4type 是 P4_FUNCDEF 时使用，函数定义 */
    sqlite3_context *pCtx; /* Used when p4type is P4_FUNCCTX - 当 p4type 是 P4_FUNCCTX 时使用，函数上下文 */
    CollSeq *pColl;        /* Used when p4type is P4_COLLSEQ - 当 p4type 是 P4_COLLSEQ 时使用，排序序列 */
    Mem *pMem;             /* Used when p4type is P4_MEM - 当 p4type 是 P4_MEM 时使用，内存值 */
    VTable *pVtab;         /* Used when p4type is P4_VTAB - 当 p4type 是 P4_VTAB 时使用，虚拟表 */
    KeyInfo *pKeyInfo;     /* Used when p4type is P4_KEYINFO - 当 p4type 是 P4_KEYINFO 时使用，键信息 */
    u32 *ai;               /* Used when p4type is P4_INTARRAY - 当 p4type 是 P4_INTARRAY 时使用，整数数组 */
    SubProgram *pProgram;  /* Used when p4type is P4_SUBPROGRAM - 当 p4type 是 P4_SUBPROGRAM 时使用，子程序 */
    Table *pTab;           /* Used when p4type is P4_TABLE - 当 p4type 是 P4_TABLE 时使用，表结构 */
    SubrtnSig *pSubrtnSig; /* Used when p4type is P4_SUBRTNSIG - 当 p4type 是 P4_SUBRTNSIG 时使用，子程序签名 */
#ifdef SQLITE_ENABLE_CURSOR_HINTS
    Expr *pExpr;           /* Used when p4type is P4_EXPR - 当 p4type 是 P4_EXPR 时使用，表达式 */
#endif
  } p4;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
  char *zComment;          /* Comment to improve readability - 用于提高可读性的注释 */
#endif
#ifdef SQLITE_VDBE_COVERAGE
  u32 iSrcLine;            /* Source-code line that generated this opcode
                           ** with flags in the upper 8 bits
                           ** 生成此操作码的源代码行号，高8位包含标志位 */
#endif
#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || defined(VDBE_PROFILE)
  u64 nExec;               /* Number of times this instruction was executed - 此指令被执行的次数 */
  u64 nCycle;              /* Number of CPU cycles consumed by this instruction - 此指令消耗的 CPU 周期数 */
#endif
};
typedef struct VdbeOp VdbeOp;


/*
** A sub-routine used to implement a trigger program.
**
** 用于实现触发器程序的子程序结构。
**
** SubProgram 结构体用于封装独立执行的字节码程序片段，主要用于：
**
** 1. 触发器实现：
**    - BEFORE/AFTER 触发器的程序逻辑
**    - INSTEAD OF 触发器的替代操作
**    - 触发器的条件和动作执行
**
** 2. 存储过程支持：
**    - 用户定义的存储过程
**    - 递归调用的程序块
**    - 参数化执行的程序单元
**
** 3. 查询优化：
**    - 子查询的独立执行
**    - 公共子表达式提取
**    - 复杂计算的封装
**
** 执行特性：
** - 独立资源：拥有独立的内存、寄存器和游标
** - 嵌套调用：支持递归和多层调用
** - 生命周期：由主程序管理和清理
** - 上下文共享：可以访问主程序的执行环境
*/
struct SubProgram {
  VdbeOp *aOp;                  /* Array of opcodes for sub-program - 子程序的操作码数组 */
  int nOp;                      /* Elements in aOp[] - aOp[] 数组中的元素数量 */
  int nMem;                     /* Number of memory cells required - 所需的内存单元数量 */
  int nCsr;                     /* Number of cursors required - 所需的游标数量 */
  u8 *aOnce;                    /* Array of OP_Once flags - OP_Once 标志位数组 */
  void *token;                  /* id that may be used to recursive triggers - 可用于递归触发的标识符 */
  SubProgram *pNext;            /* Next sub-program already visited - 下一个已访问的子程序 */
};

/*
** A smaller version of VdbeOp used for the VdbeAddOpList() function because
** it takes up less space.
*/
struct VdbeOpList {
  u8 opcode;          /* What operation to perform */
  signed char p1;     /* First operand */
  signed char p2;     /* Second parameter (often the jump destination) */
  signed char p3;     /* Third parameter */
};
typedef struct VdbeOpList VdbeOpList;

/*
** Allowed values of VdbeOp.p4type
*/
#define P4_NOTUSED      0   /* The P4 parameter is not used */
#define P4_TRANSIENT    0   /* P4 is a pointer to a transient string */
#define P4_STATIC     (-1)  /* Pointer to a static string */
#define P4_COLLSEQ    (-2)  /* P4 is a pointer to a CollSeq structure */
#define P4_INT32      (-3)  /* P4 is a 32-bit signed integer */
#define P4_SUBPROGRAM (-4)  /* P4 is a pointer to a SubProgram structure */
#define P4_TABLE      (-5)  /* P4 is a pointer to a Table structure */
/* Above do not own any resources.  Must free those below */
#define P4_FREE_IF_LE (-6)
#define P4_DYNAMIC    (-6)  /* Pointer to memory from sqliteMalloc() */
#define P4_FUNCDEF    (-7)  /* P4 is a pointer to a FuncDef structure */
#define P4_KEYINFO    (-8)  /* P4 is a pointer to a KeyInfo structure */
#define P4_EXPR       (-9) /* P4 is a pointer to an Expr tree */
#define P4_MEM        (-10) /* P4 is a pointer to a Mem*    structure */
#define P4_VTAB       (-11) /* P4 is a pointer to an sqlite3_vtab structure */
#define P4_REAL       (-12) /* P4 is a 64-bit floating point value */
#define P4_INT64      (-13) /* P4 is a 64-bit signed integer */
#define P4_INTARRAY   (-14) /* P4 is a vector of 32-bit integers */
#define P4_FUNCCTX    (-15) /* P4 is a pointer to an sqlite3_context object */
#define P4_TABLEREF   (-16) /* Like P4_TABLE, but reference counted */
#define P4_SUBRTNSIG  (-17) /* P4 is a SubrtnSig pointer */

/* Error message codes for OP_Halt */
#define P5_ConstraintNotNull 1
#define P5_ConstraintUnique  2
#define P5_ConstraintCheck   3
#define P5_ConstraintFK      4

/*
** The Vdbe.aColName array contains 5n Mem structures, where n is the 
** number of columns of data returned by the statement.
*/
#define COLNAME_NAME     0
#define COLNAME_DECLTYPE 1
#define COLNAME_DATABASE 2
#define COLNAME_TABLE    3
#define COLNAME_COLUMN   4
#ifdef SQLITE_ENABLE_COLUMN_METADATA
# define COLNAME_N        5      /* Number of COLNAME_xxx symbols */
#else
# ifdef SQLITE_OMIT_DECLTYPE
#   define COLNAME_N      1      /* Store only the name */
# else
#   define COLNAME_N      2      /* Store the name and decltype */
# endif
#endif

/*
** The following macro converts a label returned by sqlite3VdbeMakeLabel()
** into an index into the Parse.aLabel[] array that contains the resolved
** address of that label.
*/
#define ADDR(X)  (~(X))

/*
** The makefile scans the vdbe.c source file and creates the "opcodes.h"
** header file that defines a number for each opcode used by the VDBE.
*/
#include "opcodes.h"

/*
** Additional non-public SQLITE_PREPARE_* flags
*/
#define SQLITE_PREPARE_SAVESQL  0x80  /* Preserve SQL text */
#define SQLITE_PREPARE_MASK     0x1f  /* Mask of public flags */

/*
** Prototypes for the VDBE interface.  See comments on the implementation
** for a description of what each of these routines does.
*/
Vdbe *sqlite3VdbeCreate(Parse*);
Parse *sqlite3VdbeParser(Vdbe*);
int sqlite3VdbeAddOp0(Vdbe*,int);
int sqlite3VdbeAddOp1(Vdbe*,int,int);
int sqlite3VdbeAddOp2(Vdbe*,int,int,int);
int sqlite3VdbeGoto(Vdbe*,int);
int sqlite3VdbeLoadString(Vdbe*,int,const char*);
void sqlite3VdbeMultiLoad(Vdbe*,int,const char*,...);
int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);
int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);
int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);
int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);
int sqlite3VdbeAddFunctionCall(Parse*,int,int,int,int,const FuncDef*,int);
void sqlite3VdbeEndCoroutine(Vdbe*,int);
#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)
  void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N);
  void sqlite3VdbeVerifyNoResultRow(Vdbe *p);
#else
# define sqlite3VdbeVerifyNoMallocRequired(A,B)
# define sqlite3VdbeVerifyNoResultRow(A)
#endif
#if defined(SQLITE_DEBUG)
  void sqlite3VdbeVerifyAbortable(Vdbe *p, int);
  void sqlite3VdbeNoJumpsOutsideSubrtn(Vdbe*,int,int,int);
#else
# define sqlite3VdbeVerifyAbortable(A,B)
# define sqlite3VdbeNoJumpsOutsideSubrtn(A,B,C,D)
#endif
VdbeOp *sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp,int iLineno);
#ifndef SQLITE_OMIT_EXPLAIN
  int sqlite3VdbeExplain(Parse*,u8,const char*,...);
  void sqlite3VdbeExplainPop(Parse*);
  int sqlite3VdbeExplainParent(Parse*);
# define ExplainQueryPlan(P)        sqlite3VdbeExplain P
# ifdef SQLITE_ENABLE_STMT_SCANSTATUS
#  define ExplainQueryPlan2(V,P)     (V = sqlite3VdbeExplain P)
# else
#  define ExplainQueryPlan2(V,P)     ExplainQueryPlan(P)
# endif
# define ExplainQueryPlanPop(P)     sqlite3VdbeExplainPop(P)
# define ExplainQueryPlanParent(P)  sqlite3VdbeExplainParent(P)
#else
# define ExplainQueryPlan(P)
# define ExplainQueryPlan2(V,P)
# define ExplainQueryPlanPop(P)
# define ExplainQueryPlanParent(P) 0
# define sqlite3ExplainBreakpoint(A,B) /*no-op*/
#endif
#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_EXPLAIN)
  void sqlite3ExplainBreakpoint(const char*,const char*);
#else
# define sqlite3ExplainBreakpoint(A,B) /*no-op*/
#endif
void sqlite3VdbeAddParseSchemaOp(Vdbe*, int, char*, u16);
void sqlite3VdbeChangeOpcode(Vdbe*, int addr, u8);
void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);
void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);
void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);
void sqlite3VdbeChangeP5(Vdbe*, u16 P5);
void sqlite3VdbeTypeofColumn(Vdbe*, int);
void sqlite3VdbeJumpHere(Vdbe*, int addr);
void sqlite3VdbeJumpHereOrPopInst(Vdbe*, int addr);
int sqlite3VdbeChangeToNoop(Vdbe*, int addr);
int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);
#ifdef SQLITE_DEBUG
  void sqlite3VdbeReleaseRegisters(Parse*,int addr, int n, u32 mask, int);
#else
# define sqlite3VdbeReleaseRegisters(P,A,N,M,F)
#endif
void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);
void sqlite3VdbeAppendP4(Vdbe*, void *pP4, int p4type);
void sqlite3VdbeSetP4KeyInfo(Parse*, Index*);
void sqlite3VdbeUsesBtree(Vdbe*, int);
VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);
VdbeOp *sqlite3VdbeGetLastOp(Vdbe*);
int sqlite3VdbeMakeLabel(Parse*);
void sqlite3VdbeRunOnlyOnce(Vdbe*);
void sqlite3VdbeReusable(Vdbe*);
void sqlite3VdbeDelete(Vdbe*);
void sqlite3VdbeMakeReady(Vdbe*,Parse*);
int sqlite3VdbeFinalize(Vdbe*);
void sqlite3VdbeResolveLabel(Vdbe*, int);
int sqlite3VdbeCurrentAddr(Vdbe*);
#ifdef SQLITE_DEBUG
  int sqlite3VdbeAssertMayAbort(Vdbe *, int);
#endif
void sqlite3VdbeResetStepResult(Vdbe*);
void sqlite3VdbeRewind(Vdbe*);
int sqlite3VdbeReset(Vdbe*);
void sqlite3VdbeSetNumCols(Vdbe*,int);
int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));
void sqlite3VdbeCountChanges(Vdbe*);
sqlite3 *sqlite3VdbeDb(Vdbe*);
u8 sqlite3VdbePrepareFlags(Vdbe*);
void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, u8);
#ifdef SQLITE_ENABLE_NORMALIZE
void sqlite3VdbeAddDblquoteStr(sqlite3*,Vdbe*,const char*);
int sqlite3VdbeUsesDoubleQuotedString(Vdbe*,const char*);
#endif
void sqlite3VdbeSwap(Vdbe*,Vdbe*);
VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);
sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8);
void sqlite3VdbeSetVarmask(Vdbe*, int);
#ifndef SQLITE_OMIT_TRACE
  char *sqlite3VdbeExpandSql(Vdbe*, const char*);
#endif
int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);
int sqlite3BlobCompare(const Mem*, const Mem*);
#ifdef SQLITE_ENABLE_PERCENTILE
  const char *sqlite3VdbeFuncName(const sqlite3_context*);
#endif

void sqlite3VdbeRecordUnpack(int,const void*,UnpackedRecord*);
int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);
int sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int);
UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo*);

typedef int (*RecordCompare)(int,const void*,UnpackedRecord*);
RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*);

void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);
int sqlite3VdbeHasSubProgram(Vdbe*);

void sqlite3MemSetArrayInt64(sqlite3_value *aMem, int iIdx, i64 val);

#ifndef SQLITE_OMIT_DATETIME_FUNCS
int sqlite3NotPureFunc(sqlite3_context*);
#endif
#ifdef SQLITE_ENABLE_BYTECODE_VTAB
int sqlite3VdbeBytecodeVtabInit(sqlite3*);
#endif

/* Use SQLITE_ENABLE_EXPLAIN_COMMENTS to enable generation of extra
** comments on each VDBE opcode.
**
** Use the SQLITE_ENABLE_MODULE_COMMENTS macro to see some extra no-op
** comments in VDBE programs that show key decision points in the code
** generator.
*/
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
  void sqlite3VdbeComment(Vdbe*, const char*, ...);
# define VdbeComment(X)  sqlite3VdbeComment X
  void sqlite3VdbeNoopComment(Vdbe*, const char*, ...);
# define VdbeNoopComment(X)  sqlite3VdbeNoopComment X
# ifdef SQLITE_ENABLE_MODULE_COMMENTS
#   define VdbeModuleComment(X)  sqlite3VdbeNoopComment X
# else
#   define VdbeModuleComment(X)
# endif
#else
# define VdbeComment(X)
# define VdbeNoopComment(X)
# define VdbeModuleComment(X)
#endif

/*
** The VdbeCoverage macros are used to set a coverage testing point
** for VDBE branch instructions.  The coverage testing points are line
** numbers in the sqlite3.c source file.  VDBE branch coverage testing
** only works with an amalgamation build.  That's ok since a VDBE branch
** coverage build designed for testing the test suite only.  No application
** should ever ship with VDBE branch coverage measuring turned on.
**
**    VdbeCoverage(v)                  // Mark the previously coded instruction
**                                     // as a branch
**
**    VdbeCoverageIf(v, conditional)   // Mark previous if conditional true
**
**    VdbeCoverageAlwaysTaken(v)       // Previous branch is always taken
**
**    VdbeCoverageNeverTaken(v)        // Previous branch is never taken
**
**    VdbeCoverageNeverNull(v)         // Previous three-way branch is only
**                                     // taken on the first two ways.  The
**                                     // NULL option is not possible
**
**    VdbeCoverageEqNe(v)              // Previous OP_Jump is only interested
**                                     // in distinguishing equal and not-equal.
**
** Every VDBE branch operation must be tagged with one of the macros above.
** If not, then when "make test" is run with -DSQLITE_VDBE_COVERAGE and
** -DSQLITE_DEBUG then an ALWAYS() will fail in the vdbeTakeBranch()
** routine in vdbe.c, alerting the developer to the missed tag.
**
** During testing, the test application will invoke
** sqlite3_test_control(SQLITE_TESTCTRL_VDBE_COVERAGE,...) to set a callback
** routine that is invoked as each bytecode branch is taken.  The callback
** contains the sqlite3.c source line number of the VdbeCoverage macro and
** flags to indicate whether or not the branch was taken.  The test application
** is responsible for keeping track of this and reporting byte-code branches
** that are never taken.
**
** See the VdbeBranchTaken() macro and vdbeTakeBranch() function in the
** vdbe.c source file for additional information.
*/
#ifdef SQLITE_VDBE_COVERAGE
  void sqlite3VdbeSetLineNumber(Vdbe*,int);
# define VdbeCoverage(v) sqlite3VdbeSetLineNumber(v,__LINE__)
# define VdbeCoverageIf(v,x) if(x)sqlite3VdbeSetLineNumber(v,__LINE__)
# define VdbeCoverageAlwaysTaken(v) \
         sqlite3VdbeSetLineNumber(v,__LINE__|0x5000000);
# define VdbeCoverageNeverTaken(v) \
         sqlite3VdbeSetLineNumber(v,__LINE__|0x6000000);
# define VdbeCoverageNeverNull(v) \
         sqlite3VdbeSetLineNumber(v,__LINE__|0x4000000);
# define VdbeCoverageNeverNullIf(v,x) \
         if(x)sqlite3VdbeSetLineNumber(v,__LINE__|0x4000000);
# define VdbeCoverageEqNe(v) \
         sqlite3VdbeSetLineNumber(v,__LINE__|0x8000000);
# define VDBE_OFFSET_LINENO(x) (__LINE__+x)
#else
# define VdbeCoverage(v)
# define VdbeCoverageIf(v,x)
# define VdbeCoverageAlwaysTaken(v)
# define VdbeCoverageNeverTaken(v)
# define VdbeCoverageNeverNull(v)
# define VdbeCoverageNeverNullIf(v,x)
# define VdbeCoverageEqNe(v)
# define VDBE_OFFSET_LINENO(x) 0
#endif

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
void sqlite3VdbeScanStatus(Vdbe*, int, int, int, LogEst, const char*);
void sqlite3VdbeScanStatusRange(Vdbe*, int, int, int);
void sqlite3VdbeScanStatusCounters(Vdbe*, int, int, int);
#else
# define sqlite3VdbeScanStatus(a,b,c,d,e,f)
# define sqlite3VdbeScanStatusRange(a,b,c,d)
# define sqlite3VdbeScanStatusCounters(a,b,c,d)
#endif

#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
void sqlite3VdbePrintOp(FILE*, int, VdbeOp*);
#endif

#if defined(SQLITE_ENABLE_CURSOR_HINTS) && defined(SQLITE_DEBUG)
int sqlite3CursorRangeHintExprCheck(Walker *pWalker, Expr *pExpr);
#endif

#endif /* SQLITE_VDBE_H */
