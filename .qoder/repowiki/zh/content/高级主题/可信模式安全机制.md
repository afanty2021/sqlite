# 可信模式安全机制

<cite>
**本文档引用的文件**  
- [trusted-schema.md](file://doc/trusted-schema.md)
- [main.c](file://src/main.c)
- [pragma.c](file://src/pragma.c)
- [func.c](file://src/func.c)
- [sqliteInt.h](file://src/sqliteInt.h)
- [vtab.c](file://src/vtab.c)
- [noop.c](file://ext/misc/noop.c)
</cite>

## 目录
1. [引言](#引言)
2. [可信模式设计目标](#可信模式设计目标)
3. [风险函数分类体系](#风险函数分类体系)
4. [可信模式控制机制](#可信模式控制机制)
5. [函数与虚拟表标记实现](#函数与虚拟表标记实现)
6. [安全审计与函数列表](#安全审计与函数列表)
7. [TEMP对象的特殊处理](#temp对象的特殊处理)
8. [结论](#结论)

## 引言

SQLite的可信模式（Trusted Schema）是一项重要的安全特性，旨在防止攻击者通过篡改数据库模式来诱导高权限应用程序执行危险操作或泄露敏感信息。当一个高权限应用打开一个可能被恶意篡改的数据库文件时，攻击者可能通过替换表为视图、添加恶意触发器或在索引、CHECK约束中嵌入表达式来执行具有副作用的SQL函数。可信模式通过引入风险分类和执行限制，为应用程序提供了抵御此类攻击的防御机制。

**Section sources**
- [trusted-schema.md](file://doc/trusted-schema.md#L0-L17)

## 可信模式设计目标

可信模式的核心设计目标是解决“模式注入”（Schema Injection）带来的安全风险。攻击者可以利用此漏洞修改数据库的模式定义，从而在高权限应用读取数据库时，间接执行恶意代码。具体攻击向量包括：
- 将普通表替换为视图，视图的SELECT语句中调用危险函数。
- 在表或视图上添加触发器（TRIGGER），在INSERT、UPDATE或DELETE操作时执行恶意逻辑。
- 在索引、CHECK约束、DEFAULT值或生成列中使用包含危险函数的表达式。

如果这些被篡改的模式结构调用了具有副作用（如文件系统读写、网络访问）或能泄露外部信息的SQL函数，就可能对系统造成危害。可信模式通过限制这些“直接调用专用”（Direct-Only）函数的执行上下文，确保它们只能由应用程序直接调用，而不能在模式定义的上下文中被间接触发。

**Section sources**
- [trusted-schema.md](file://doc/trusted-schema.md#L0-L17)

## 风险函数分类体系

SQLite将所有SQL函数和虚拟表分为三个风险级别，以精确控制其执行权限：

1.  **无害（Innocuous）**：此类函数是安全的，可以在任何上下文中调用。它们只能读取和修改其所在的数据库文件，不会产生任何外部副作用。例如，`abs()`、`length()`等内置函数都属于此类。

2.  **仅限直接调用（Direct-Only）**：此类函数具有潜在风险，可能产生外部副作用或访问数据库外部的信息。它们只能由应用程序通过顶层SQL语句直接调用，禁止在视图、触发器或模式定义（如CHECK约束、索引表达式）中使用。典型的例子包括`readfile()`、`writefile()`和`fts3_tokenizer()`。

3.  **普通（Normal）**：这是一个中间风险级别。其行为取决于`TRUSTED_SCHEMA`的设置：
    -   当`TRUSTED_SCHEMA=ON`（默认）时，`Normal`函数的行为与`Innocuous`相同，可以自由使用。
    -   当`TRUSTED_SCHEMA=OFF`时，`Normal`函数的行为与`Direct-Only`相同，受到严格限制。

应用程序自定义的函数和虚拟表默认被标记为`Normal`，这在保证向后兼容性的同时，也为开发者提供了提升安全性的途径。

**Section sources**
- [trusted-schema.md](file://doc/trusted-schema.md#L19-L56)

## 可信模式控制机制

应用程序可以通过多种方式控制可信模式的行为和函数的风险级别：

### 1. 通过 `sqlite3_db_config()`
这是C/C++应用程序控制可信模式的主要方式。使用`SQLITE_DBCONFIG_TRUSTED_SCHEMA`选项可以开启或关闭可信模式。
```c
// 关闭可信模式
int isTrusted;
sqlite3_db_config(db, SQLITE_DBCONFIG_TRUSTED_SCHEMA, 0, &isTrusted);
```

### 2. 通过 `PRAGMA trusted_schema`
对于使用脚本语言（如Python、Tcl）的应用程序，可以通过SQL指令来控制该设置。
```sql
-- 关闭可信模式
PRAGMA trusted_schema=OFF;
```

### 3. 编译时选项
在编译SQLite库时，可以通过`-DSQLITE_TRUSTED_SCHEMA=0`来将默认的可信模式设置为关闭，强制所有应用在更安全的配置下运行。

**Section sources**
- [trusted-schema.md](file://doc/trusted-schema.md#L80-L124)
- [main.c](file://src/main.c#L949-L1029)

## 函数与虚拟表标记实现

开发者在创建自定义函数或虚拟表时，可以明确指定其风险级别，以覆盖默认的`Normal`行为。

### 1. 标记自定义函数
在调用`sqlite3_create_function()`系列函数时，可以将`SQLITE_INNOCUOUS`或`SQLITE_DIRECTONLY`标志与编码参数（`enc`）进行按位或操作。
```c
// 创建一个无害函数
sqlite3_create_function(db, "my_innocuous_func", 1,
                        SQLITE_UTF8 | SQLITE_INNOCUOUS,
                        0, myFunc, 0, 0);

// 创建一个仅限直接调用的函数
sqlite3_create_function(db, "my_directonly_func", 1,
                        SQLITE_UTF8 | SQLITE_DIRECTONLY,
                        0, myFunc, 0, 0);
```
在`ext/misc/noop.c`扩展中，`sqlite3_noop_init`函数就展示了这种用法，它同时注册了`noop_i`（无害）和`noop_do`（仅限直接调用）两个变体。

### 2. 标记虚拟表
对于虚拟表，可以使用`sqlite3_vtab_config()`函数进行配置。
```c
// 在xConnect或xCreate方法中
sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);   // 标记为无害
sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);  // 标记为仅限直接调用
```

在内部实现上，`SQLITE_INNOCUOUS`和`SQLITE_DIRECTONLY`标志最终会被映射到`FuncDef.flags`和`VTable.eVtabRisk`字段中，供虚拟机（VDBE）在执行时进行安全检查。

**Section sources**
- [trusted-schema.md](file://doc/trusted-schema.md#L80-L124)
- [main.c](file://src/main.c#L1899-L1959)
- [vtab.c](file://src/vtab.c#L1336-L1376)
- [noop.c](file://ext/misc/noop.c#L58-L89)

## 安全审计与函数列表

为了便于安全审计，SQLite增强了`PRAGMA function_list`和`PRAGMA module_list`的输出，增加了`flags`等关键字段。

### 1. 增强的 `PRAGMA function_list`
该指令现在返回一个包含`flags`列的结果集，该列是一个位掩码，包含了`SQLITE_INNOCUOUS`、`SQLITE_DIRECTONLY`等标志。
```sql
-- 查询所有函数及其风险标志
PRAGMA function_list;
```
返回的列包括：`name`, `builtin`, `type`, `enc`, `narg`, `flags`。

### 2. 安全审计查询
利用`flags`列，管理员可以编写SQL查询来识别高风险函数。例如，以下查询可以找出所有被标记为`Direct-Only`的函数：
```sql
SELECT DISTINCT name FROM pragma_function_list
WHERE (flags & 0x80000) != 0
ORDER BY name;
```
这为安全审查和漏洞排查提供了强大的工具。

**Section sources**
- [trusted-schema.md](file://doc/trusted-schema.md#L80-L124)
- [pragma.c](file://src/pragma.c#L1460-L1502)
- [pragma.c](file://src/pragma.c#L303-L352)

## TEMP对象的特殊处理

可信模式对`TEMP`对象（临时表、临时视图、临时触发器）有特殊的处理规则：它们不受`TRUSTED_SCHEMA`设置的限制。

### 设计原因
这一设计基于一个关键的安全假设：`TEMP`对象只能由应用程序通过直接的SQL命令创建，而不能由攻击者通过篡改持久化数据库文件来注入。因为`TEMP`对象存在于临时数据库中，其模式不会被持久化到磁盘上的主数据库文件里。因此，可以认为所有`TEMP`对象都处于应用程序的完全控制之下，是可信的。这一设计在保证核心安全的同时，避免了对应用程序正常功能的过度限制。

**Section sources**
- [trusted-schema.md](file://doc/trusted-schema.md#L56-L65)

## 结论

SQLite的可信模式是一项深思熟虑的安全增强功能。它通过三级风险分类体系（Innocuous、Normal、Direct-Only）和灵活的控制机制（`sqlite3_db_config`、`PRAGMA trusted_schema`、创建函数时的标志），为开发者提供了抵御模式注入攻击的有效手段。虽然默认开启`TRUSTED_SCHEMA`是为了向后兼容，但文档强烈建议高权限应用在启动时将其关闭，以获得更强的安全保障。结合`PRAGMA function_list`的审计功能，开发者可以全面掌控数据库中函数的安全状态，构建更安全的应用程序。