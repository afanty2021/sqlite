# 错误处理

<cite>
**本文档引用的文件**   
- [main.c](file://src/main.c)
- [vdbe.c](file://src/vdbe.c)
- [sqliteInt.h](file://src/sqliteInt.h)
- [os_win.c](file://src/os_win.c)
- [os_unix.c](file://src/os_unix.c)
- [pager.c](file://src/pager.c)
</cite>

## 目录
1. [简介](#简介)
2. [标准结果码分类与含义](#标准结果码分类与含义)
3. [扩展结果码分类与含义](#扩展结果码分类与含义)
4. [错误处理函数使用方法](#错误处理函数使用方法)
5. [基于错误码的条件判断与故障排查](#基于错误码的条件判断与故障排查)
6. [典型错误场景分析](#典型错误场景分析)
7. [恢复策略与容错程序构建](#恢复策略与容错程序构建)
8. [结论](#结论)

## 简介

SQLite数据库系统提供了一套完善的错误处理机制，通过标准结果码和扩展结果码来精确描述各种错误情况。本文档旨在全面介绍这些错误码的分类与含义，详细说明相关错误处理函数的使用方法，并结合代码实现分析典型错误场景的成因及恢复策略，帮助开发者构建健壮的容错程序。

**Section sources**
- [main.c](file://src/main.c#L1518-L1664)

## 标准结果码分类与含义

SQLite定义了一系列标准结果码，用于表示不同类型的错误。这些结果码在`main.c`文件中通过`sqlite3ErrStr`函数进行描述：

- **SQLITE_OK**: 操作成功，无错误
- **SQLITE_ERROR**: SQL逻辑错误
- **SQLITE_INTERNAL**: 内部系统错误
- **SQLITE_PERM**: 访问权限被拒绝
- **SQLITE_ABORT**: 查询被中止
- **SQLITE_BUSY**: 数据库被锁定
- **SQLITE_LOCKED**: 数据库表被锁定
- **SQLITE_NOMEM**: 内存不足
- **SQLITE_READONLY**: 尝试写入只读数据库
- **SQLITE_INTERRUPT**: 操作被中断
- **SQLITE_IOERR**: 磁盘I/O错误
- **SQLITE_CORRUPT**: 数据库磁盘映像损坏
- **SQLITE_NOTFOUND**: 未知操作
- **SQLITE_FULL**: 数据库或磁盘已满
- **SQLITE_CANTOPEN**: 无法打开数据库文件
- **SQLITE_PROTOCOL**: 锁定协议错误
- **SQLITE_EMPTY**: 空结果集
- **SQLITE_SCHEMA**: 数据库模式已更改
- **SQLITE_TOOBIG**: 字符串或BLOB过大
- **SQLITE_CONSTRAINT**: 约束失败
- **SQLITE_MISMATCH**: 数据类型不匹配
- **SQLITE_MISUSE**: 参数错误或其他API误用

这些标准结果码为应用程序提供了基本的错误信息，帮助开发者快速识别问题类型。

**Section sources**
- [main.c](file://src/main.c#L1634-L1664)

## 扩展结果码分类与含义

在标准结果码的基础上，SQLite还提供了更详细的扩展结果码，用于更精确地描述特定的错误情况。扩展结果码通常由标准结果码加上一个偏移量构成，主要分为以下几类：

### I/O错误扩展码
- **SQLITE_IOERR_READ**: 读取失败
- **SQLITE_IOERR_SHORT_READ**: 读取数据量不足
- **SQLITE_IOERR_WRITE**: 写入失败
- **SQLITE_IOERR_FSYNC**: fsync()系统调用失败
- **SQLITE_IOERR_TRUNCATE**: 截断文件失败
- **SQLITE_IOERR_FSTAT**: 获取文件状态失败
- **SQLITE_IOERR_UNLOCK**: 解锁失败
- **SQLITE_IOERR_RDLOCK**: 读取锁定失败
- **SQLITE_IOERR_DELETE**: 删除文件失败
- **SQLITE_IOERR_NOMEM**: 内存分配失败
- **SQLITE_IOERR_ACCESS**: 访问权限错误
- **SQLITE_IOERR_CHECKRESERVEDLOCK**: 检查保留锁失败
- **SQLITE_IOERR_LOCK**: 锁定失败
- **SQLITE_IOERR_CLOSE**: 关闭文件失败
- **SQLITE_IOERR_DIR_CLOSE**: 关闭目录失败
- **SQLITE_IOERR_SHMOPEN**: 共享内存打开失败
- **SQLITE_IOERR_SHMSIZE**: 共享内存大小错误
- **SQLITE_IOERR_SHMLOCK**: 共享内存锁定失败
- **SQLITE_IOERR_SHMMAP**: 共享内存映射失败
- **SQLITE_IOERR_SEEK**: 文件定位失败
- **SQLITE_IOERR_DELETE_NOENT**: 尝试删除不存在的文件
- **SQLITE_IOERR_MMAP**: 内存映射失败
- **SQLITE_IOERR_GETTEMPPATH**: 获取临时路径失败
- **SQLITE_IOERR_CONVPATH**: 路径转换失败
- **SQLITE_IOERR_VNODE**: VNODE协议错误
- **SQLITE_IOERR_AUTH**: 授权失败
- **SQLITE_IOERR_BEGIN_ATOMIC**: 原子操作开始失败
- **SQLITE_IOERR_COMMIT_ATOMIC**: 原子操作提交失败
- **SQLITE_IOERR_ROLLBACK_ATOMIC**: 原子操作回滚失败
- **SQLITE_IOERR_DATA**: 数据错误
- **SQLITE_IOERR_CORRUPTFS**: 文件系统损坏

### 锁定相关扩展码
- **SQLITE_LOCKED_SHAREDCACHE**: 共享缓存锁定
- **SQLITE_LOCKED_VTAB**: 虚拟表锁定

### 忙碌状态扩展码
- **SQLITE_BUSY_RECOVERY**: 恢复过程中数据库繁忙
- **SQLITE_BUSY_SNAPSHOT**: 快照不可用
- **SQLITE_BUSY_TIMEOUT**: 忙碌超时

### 无法打开扩展码
- **SQLITE_CANTOPEN_NOTEMPDIR**: 无临时目录
- **SQLITE_CANTOPEN_ISDIR**: 尝试打开目录而非文件
- **SQLITE_CANTOPEN_FULLPATH**: 完整路径打开失败
- **SQLITE_CANTOPEN_CONVPATH**: 路径转换失败
- **SQLITE_CANTOPEN_SYMLINK**: 符号链接错误

### 约束失败扩展码
- **SQLITE_CONSTRAINT_UNIQUE**: 唯一性约束失败
- **SQLITE_CONSTRAINT_TRIGGER**: 触发器约束失败
- **SQLITE_CONSTRAINT_FOREIGNKEY**: 外键约束失败
- **SQLITE_CONSTRAINT_CHECK**: CHECK约束失败
- **SQLITE_CONSTRAINT_PRIMARYKEY**: 主键约束失败
- **SQLITE_CONSTRAINT_NOTNULL**: NOT NULL约束失败
- **SQLITE_CONSTRAINT_COMMITHOOK**: 提交钩子约束失败
- **SQLITE_CONSTRAINT_VTAB**: 虚拟表约束失败
- **SQLITE_CONSTRAINT_FUNCTION**: 函数约束失败
- **SQLITE_CONSTRAINT_ROWID**: ROWID约束失败

### 只读模式扩展码
- **SQLITE_READONLY_RECOVERY**: 恢复过程中只读
- **SQLITE_READONLY_CANTINIT**: 无法初始化只读数据库
- **SQLITE_READONLY_ROLLBACK**: 回滚过程中只读
- **SQLITE_READONLY_DBMOVED**: 数据库文件被移动
- **SQLITE_READONLY_DIRECTORY**: 目录只读

### 通知与警告扩展码
- **SQLITE_NOTICE_RECOVER_WAL**: WAL恢复通知
- **SQLITE_NOTICE_RECOVER_ROLLBACK**: 回滚恢复通知
- **SQLITE_NOTICE_RBU**: RBU通知
- **SQLITE_WARNING_AUTOINDEX**: 自动索引警告

这些扩展结果码提供了更详细的错误信息，使开发者能够更精确地诊断和处理问题。

**Section sources**
- [main.c](file://src/main.c#L1518-L1632)
- [main.c](file://src/main.c#L1541-L1590)

## 错误处理函数使用方法

SQLite提供了多个函数来获取和处理错误信息，这些函数在`main.c`文件中实现：

### sqlite3_errcode
该函数返回最近一次操作的标准结果码。它通过屏蔽扩展码的高位部分，只返回基本的错误类型。

```c
int sqlite3_errcode(sqlite3 *db){
  if( db && !sqlite3SafetyCheckSickOrOk(db) ){
    return SQLITE_MISUSE_BKPT;
  }
  if( !db || db->mallocFailed ){
    return SQLITE_NOMEM_BKPT;
  }
  return db->errCode & db->errMask;
}
```

### sqlite3_extended_errcode
该函数返回最近一次操作的完整结果码，包括扩展码信息。这对于需要精确错误诊断的应用程序非常有用。

```c
int sqlite3_extended_errcode(sqlite3 *db){
  if( db && !sqlite3SafetyCheckSickOrOk(db) ){
    return SQLITE_MISUSE_BKPT;
  }
  if( !db || db->mallocFailed ){
    return SQLITE_NOMEM_BKPT;
  }
  return db->errCode;
}
```

### sqlite3_errmsg
该函数返回最近一次错误的UTF-8编码的英文描述信息。它首先检查是否有自定义的错误消息，如果没有则使用标准的错误描述。

```c
const char *sqlite3_errmsg(sqlite3 *db){
  const char *z;
  if( !db ){
    return sqlite3ErrStr(SQLITE_NOMEM_BKPT);
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3ErrStr(SQLITE_MISUSE_BKPT);
  }
  sqlite3_mutex_enter(db->mutex);
  if( db->mallocFailed ){
    z = sqlite3ErrStr(SQLITE_NOMEM_BKPT);
  }else{
    testcase( db->pErr==0 );
    z = db->errCode ? (char*)sqlite3_value_text(db->pErr) : 0;
    assert( !db->mallocFailed );
    if( z==0 ){
      z = sqlite3ErrStr(db->errCode);
    }
  }
  sqlite3_mutex_leave(db->mutex);
  return z;
}
```

### sqlite3_errstr
该函数根据结果码返回相应的错误描述字符串。它使用一个静态数组来存储各种错误的描述信息。

```c
const char *sqlite3ErrStr(int rc){
  static const char* const aMsg[] = {
    /* SQLITE_OK          */ "not an error",
    /* SQLITE_ERROR       */ "SQL logic error",
    /* SQLITE_INTERNAL    */ 0,
    /* SQLITE_PERM        */ "access permission denied",
    /* SQLITE_ABORT       */ "query aborted",
    /* SQLITE_BUSY        */ "database is locked",
    /* SQLITE_LOCKED      */ "database table is locked",
    /* SQLITE_NOMEM       */ "out of memory",
    /* SQLITE_READONLY    */ "attempt to write a readonly database",
    /* SQLITE_INTERRUPT   */ "interrupted",
    /* SQLITE_IOERR       */ "disk I/O error",
    /* SQLITE_CORRUPT     */ "database disk image is malformed",
    /* SQLITE_NOTFOUND    */ "unknown operation",
    /* SQLITE_FULL        */ "database or disk is full",
    /* SQLITE_CANTOPEN    */ "unable to open database file",
    /* SQLITE_PROTOCOL    */ "locking protocol",
    /* SQLITE_EMPTY       */ 0,
    /* SQLITE_SCHEMA      */ "database schema has changed",
    /* SQLITE_TOOBIG      */ "string or blob too big",
    /* SQLITE_CONSTRAINT  */ "constraint failed",
    /* SQLITE_MISMATCH    */ "datatype mismatch",
    /* SQLITE_MISUSE      */ "bad parameter or other API misuse",
#ifdef SQLITE_DISABLE_LFS
    /* SQLITE_NOLFS       */ "large file support is disabled",
#else
    /* SQLITE_NOLFS       */ 0,
#endif
    /* SQLITE_AUTH        */ "authorization denied",
    /* SQLITE_FORMAT      */ 0,
    /* SQLITE_RANGE       */ "column index out of range",
    /* SQLITE_NOTADB      */ "file is not a database",
    /* SQLITE_NOTICE      */ "notification message",
    /* SQLITE_WARNING     */ "warning message",
  };
  const char *zErr = "unknown error";
  switch( rc ){
    case SQLITE_ABORT_ROLLBACK: {
      zErr = "abort due to ROLLBACK";
      break;
    }
    case SQLITE_ROW: {
      zErr = "another row available";
      break;
    }
    case SQLITE_DONE: {
      zErr = "no more rows available";
      break;
    }
    default: {
      rc &= 0xff;
      if( ALWAYS(rc>=0) && rc<ArraySize(aMsg) && aMsg[rc]!=0 ){
        zErr = aMsg[rc];
      }
      break;
    }
  }
  return zErr;
}
```

### sqlite3_error_offset
该函数返回最近一次错误的字节偏移量，用于定位SQL语句中的错误位置。

```c
int sqlite3_error_offset(sqlite3 *db){
  int iOffset = -1;
  if( db && sqlite3SafetyCheckSickOrOk(db) && db->errCode ){
    sqlite3_mutex_enter(db->mutex);
    iOffset = db->errByteOffset;
    sqlite3_mutex_leave(db->mutex);
  }
  return iOffset;
}
```

这些函数共同构成了SQLite的错误处理接口，为应用程序提供了丰富的错误信息。

**Section sources**
- [main.c](file://src/main.c#L2688-L2764)
- [main.c](file://src/main.c#L2807-L2819)

## 基于错误码的条件判断与故障排查

在实际应用中，开发者需要根据不同的错误码采取相应的处理策略。以下是一些常见的错误处理范例：

### 数据库锁定处理
当遇到`SQLITE_BUSY`或`SQLITE_LOCKED`错误时，应用程序应该实现重试机制：

```c
int handle_busy_error(sqlite3 *db) {
    int rc = sqlite3_extended_errcode(db);
    if (rc == SQLITE_BUSY || rc == SQLITE_BUSY_RECOVERY) {
        // 实现指数退避重试策略
        for (int i = 0; i < MAX_RETRY_ATTEMPTS; i++) {
            sqlite3_sleep((1 << i) * 100); // 指数退避
            // 重新执行操作
            rc = execute_operation(db);
            if (rc != SQLITE_BUSY && rc != SQLITE_BUSY_RECOVERY) {
                break;
            }
        }
    }
    return rc;
}
```

### I/O错误处理
对于I/O错误，需要区分可恢复和不可恢复的错误：

```c
int handle_io_error(sqlite3 *db) {
    int rc = sqlite3_extended_errcode(db);
    switch (rc) {
        case SQLITE_IOERR_READ:
        case SQLITE_IOERR_WRITE:
        case SQLITE_IOERR_FSYNC:
            // 可能是临时性I/O问题，尝试重试
            return retry_operation(db);
            
        case SQLITE_IOERR_NOMEM:
            // 内存不足，需要释放资源或终止操作
            return SQLITE_ERROR;
            
        case SQLITE_IOERR_DELETE:
        case SQLITE_IOERR_ACCESS:
            // 权限或文件系统问题，通常不可恢复
            return SQLITE_PERM;
            
        default:
            // 其他I/O错误，根据具体情况处理
            return rc;
    }
}
```

### 约束失败处理
当遇到约束失败时，应用程序应该根据具体的约束类型采取不同的处理策略：

```c
int handle_constraint_error(sqlite3 *db) {
    int rc = sqlite3_extended_errcode(db);
    switch (rc) {
        case SQLITE_CONSTRAINT_UNIQUE:
            // 唯一性约束失败，可能需要生成新的唯一值
            return handle_unique_constraint(db);
            
        case SQLITE_CONSTRAINT_FOREIGNKEY:
            // 外键约束失败，需要检查引用完整性
            return handle_foreign_key_constraint(db);
            
        case SQLITE_CONSTRAINT_NOTNULL:
            // NOT NULL约束失败，需要提供默认值
            return handle_notnull_constraint(db);
            
        default:
            // 其他约束失败
            return rc;
    }
}
```

### 只读数据库处理
当尝试写入只读数据库时，需要检查数据库状态：

```c
int handle_readonly_error(sqlite3 *db) {
    int rc = sqlite3_extended_errcode(db);
    switch (rc) {
        case SQLITE_READONLY:
        case SQLITE_READONLY_RECOVERY:
            // 数据库处于只读模式，可能需要重新打开
            return reopen_database_readwrite(db);
            
        case SQLITE_READONLY_DBMOVED:
            // 数据库文件被移动，需要重新定位
            return relocate_database(db);
            
        default:
            return rc;
    }
}
```

这些处理范例展示了如何根据不同的错误码采取相应的恢复策略，构建健壮的容错程序。

**Section sources**
- [main.c](file://src/main.c#L2688-L2736)
- [main.c](file://src/main.c#L1634-L1664)

## 典型错误场景分析

### 数据库锁定场景

数据库锁定是SQLite中最常见的错误之一，主要发生在多进程或多线程环境中。在`pager.c`文件中，`pager_wait_on_lock`函数实现了锁定等待逻辑：

```c
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;                              /* Return code */

  assert( (pPager->eLock>=locktype)
       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)
       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)
  );

  do {
    rc = pagerLockDb(pPager, locktype);
  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
  return rc;
}
```

当一个进程尝试获取锁而另一个进程已经持有锁时，`sqlite3OsLock`系统调用会返回`SQLITE_BUSY`。此时，SQLite会调用忙处理程序（busy handler），如果忙处理程序返回true，则继续重试；如果返回false，则放弃并返回`SQLITE_BUSY`错误。

在Windows系统中，`os_win.c`文件中的`winRetryIoerr`函数实现了I/O错误重试机制：

```c
static int winRetryIoerr(int *pnRetry, DWORD *pError){
  DWORD e = osGetLastError();
  if( *pnRetry>=winIoerrRetry ){
    if( pError ){
      *pError = e;
    }
    return 0;
  }
  if( winIoerrCanRetry1(e) ){
    sqlite3_win32_sleep(winIoerrRetryDelay*(1+*pnRetry));
    ++*pnRetry;
    return 1;
  }
#if defined(winIoerrCanRetry2)
  else if( winIoerrCanRetry2(e) ){
    sqlite3_win32_sleep(winIoerrRetryDelay*(1+*pnRetry));
    ++*pnRetry;
    return 1;
  }
#endif
  if( pError ){
    *pError = e;
  }
  return 0;
}
```

### 磁盘I/O失败场景

磁盘I/O失败可能由多种原因引起，包括硬件故障、权限问题、磁盘空间不足等。在`os_unix.c`文件中，`sqliteErrorFromPosixError`函数将POSIX错误码转换为SQLite错误码：

```c
static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {
  assert( (sqliteIOErr == SQLITE_IOERR_LOCK) ||
          (sqliteIOErr == SQLITE_IOERR_UNLOCK) ||
          (sqliteIOErr == SQLITE_IOERR_RDLOCK) ||
          (sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK) );
  switch (posixError) {
  case EACCES:
  case EAGAIN:
  case ETIMEDOUT:
  case EBUSY:
  case EINTR:
  case ENOLCK:
    return SQLITE_BUSY;
  
  case EPERM:
    return SQLITE_PERM;
  
  default:
    return sqliteIOErr;
  }
}
```

当发生I/O错误时，SQLite会根据具体的错误类型返回相应的扩展结果码。例如：
- `EACCES`或`EPERM`错误会转换为`SQLITE_PERM`
- `ENOSPC`错误会转换为`SQLITE_FULL`
- `EIO`错误会转换为各种`SQLITE_IOERR_*`扩展码

在`os_win.c`文件中，`winLogErrorAtLine`函数记录了详细的I/O错误信息：

```c
static int winLogErrorAtLine(
  int errcode,                    /* SQLite error code */
  DWORD lastErrno,                /* Win32 last error */
  const char *zFunc,              /* Name of OS function that failed */
  const char *zPath,              /* File path associated with error */
  int iLine                       /* Source line number where error occurred */
){
  char zMsg[500];                 /* Human readable error text */
  int i;                          /* Loop counter */

  zMsg[0] = 0;
  winGetLastErrorMsg(lastErrno, sizeof(zMsg), zMsg);
  assert( errcode!=SQLITE_OK );
  if( zPath==0 ) zPath = "";
  for(i=0; zMsg[i] && zMsg[i]!='\r' && zMsg[i]!='\n'; i++){}
  zMsg[i] = 0;
  sqlite3_log(errcode,
      "os_win.c:%d: (%lu) %s(%s) - %s",
      iLine, lastErrno, zFunc, zPath, zMsg
  );
}
```

这些详细的错误日志有助于诊断和解决I/O问题。

**Section sources**
- [pager.c](file://src/pager.c#L3915-L3960)
- [os_win.c](file://src/os_win.c#L2270-L2311)
- [os_unix.c](file://src/os_unix.c#L878-L932)

## 恢复策略与容错程序构建

### 错误恢复策略

#### 重试机制
对于临时性错误，如`SQLITE_BUSY`，应该实现智能重试机制：

```c
int sqliteDefaultBusyCallback(
  void *ptr,               /* Database connection */
  int count                /* Number of times table has been busy */
){
  static const u8 delays[] =
     { 1, 2, 5, 10, 15, 20, 25, 25,  25,  50,  50, 100 };
  static const u8 totals[] =
     { 0, 1, 3,  8, 18, 33, 53, 78, 103, 128, 178, 228 };
# define NDELAY ArraySize(delays)
  sqlite3 *db = (sqlite3 *)ptr;
  int tmout = db->busyTimeout;
  int delay, prior;

  assert( count>=0 );
  if( count < NDELAY ){
    delay = delays[count];
    prior = totals[count];
  }else{
    delay = delays[NDELAY-1];
    prior = totals[NDELAY-1] + delay*(count-(NDELAY-1));
  }
  if( prior + delay > tmout ){
    delay = tmout - prior;
    if( delay<=0 ) return 0;
  }
  sqlite3OsSleep(db->pVfs, delay*1000);
  return 1;
}
```

这个默认的忙回调函数实现了指数退避策略，随着重试次数增加，等待时间也相应增加。

#### 事务回滚
当遇到不可恢复的错误时，应该及时回滚事务：

```c
int handle_fatal_error(sqlite3 *db) {
    int rc = sqlite3_extended_errcode(db);
    switch (rc) {
        case SQLITE_CORRUPT:
        case SQLITE_NOTADB:
        case SQLITE_IOERR_CORRUPTFS:
            // 数据库损坏，需要修复或重建
            sqlite3_exec(db, "ROLLBACK;", 0, 0, 0);
            return repair_database(db);
            
        case SQLITE_NOMEM:
            // 内存不足，释放资源后重试
            sqlite3_release_memory(1024);
            return retry_operation(db);
            
        default:
            // 其他错误，根据具体情况处理
            sqlite3_exec(db, "ROLLBACK;", 0, 0, 0);
            return rc;
    }
}
```

### 容错程序构建

#### 错误处理框架
构建一个统一的错误处理框架：

```c
typedef struct {
    int (*handler)(sqlite3 *db, int errcode);
    int errcode;
} error_handler_t;

static error_handler_t error_handlers[] = {
    {handle_busy_error, SQLITE_BUSY},
    {handle_io_error, SQLITE_IOERR},
    {handle_constraint_error, SQLITE_CONSTRAINT},
    {handle_readonly_error, SQLITE_READONLY},
    {0, 0} // 结束标记
};

int dispatch_error(sqlite3 *db) {
    int rc = sqlite3_extended_errcode(db);
    for (int i = 0; error_handlers[i].handler != 0; i++) {
        if ((rc & 0xff) == error_handlers[i].errcode) {
            return error_handlers[i].handler(db, rc);
        }
    }
    return rc; // 默认处理
}
```

#### 健壮的数据库操作
实现健壮的数据库操作函数：

```c
int safe_database_operation(sqlite3 *db, const char *sql) {
    int rc;
    int attempts = 0;
    const int max_attempts = 3;
    
    while (attempts < max_attempts) {
        rc = sqlite3_exec(db, sql, 0, 0, 0);
        
        if (rc == SQLITE_OK) {
            break; // 成功
        }
        
        rc = dispatch_error(db);
        
        if (rc != SQLITE_BUSY && rc != SQLITE_LOCKED) {
            break; // 不可恢复的错误
        }
        
        attempts++;
        if (attempts < max_attempts) {
            sqlite3_sleep(100 * attempts); // 退避
        }
    }
    
    return rc;
}
```

#### 监控与日志
实现错误监控和日志记录：

```c
void setup_error_logging(sqlite3 *db) {
    sqlite3_config(SQLITE_CONFIG_LOG, error_log_callback, 0);
}

void error_log_callback(void *pArg, int iErrCode, const char *zMsg) {
    // 记录错误日志
    fprintf(stderr, "SQLite Error %d: %s\n", iErrCode, zMsg);
    
    // 根据错误类型采取相应措施
    if (iErrCode == SQLITE_CORRUPT) {
        send_alert("Database corruption detected!");
    }
}
```

通过这些策略，可以构建出健壮的容错程序，有效处理各种错误情况，确保应用程序的稳定运行。

**Section sources**
- [main.c](file://src/main.c#L1699-L1770)
- [pager.c](file://src/pager.c#L6407-L6432)

## 结论

SQLite的错误处理机制通过标准结果码和扩展结果码提供了丰富的错误信息，帮助开发者准确诊断和处理各种问题。通过合理使用`sqlite3_errcode`、`sqlite3_extended_errcode`、`sqlite3_errmsg`等函数，可以获取详细的错误信息。针对不同的错误场景，如数据库锁定、磁盘I/O失败等，应该采取相应的恢复策略，包括重试机制、事务回滚等。构建健壮的容错程序需要综合考虑各种错误情况，实现统一的错误处理框架，确保应用程序的稳定性和可靠性。理解并正确使用这些错误处理机制，是开发高质量SQLite应用程序的关键。