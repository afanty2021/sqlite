# 高级控制选项

<cite>
**本文档中引用的文件**
- [testrunner.tcl](file://test/testrunner.tcl)
- [testrunner.md](file://doc/testrunner.md)
- [testrunner_data.tcl](file://test/testrunner_data.tcl)
</cite>

## 目录
1. [概述](#概述)
2. [核心高级控制选项](#核心高级控制选项)
3. [预览和调试选项](#预览和调试选项)
4. [构建控制选项](#构建控制选项)
5. [动态资源管理](#动态资源管理)
6. [状态监控和辅助命令](#状态监控和辅助命令)
7. [使用场景和最佳实践](#使用场景和最佳实践)
8. [故障排除指南](#故障排除指南)

## 概述

testrunner.tcl是SQLite项目的核心测试框架，提供了丰富的高级控制选项来优化测试执行、调试问题和管理资源。这些选项允许开发者在不同阶段预览测试行为、控制构建过程、动态调整并发作业数，并实时监控测试状态。

## 核心高级控制选项

### 命令行参数解析机制

testrunner.tcl通过专门的命令行解析器处理各种高级选项：

```mermaid
flowchart TD
A["命令行输入"] --> B["参数解析循环"]
B --> C{"检查参数类型"}
C --> |"--jobs"| D["设置并发作业数"]
C --> |"--buildonly"| E["启用构建模式"]
C --> |"--dryrun"| F["启用干运行模式"]
C --> |"--explain"| G["启用解释模式"]
C --> |"--status"| H["启用状态监控"]
C --> |其他参数| I["标准测试参数"]
D --> J["更新TRG(nJob)"]
E --> K["设置TRG(buildonly)"]
F --> L["设置TRG(dryrun)"]
G --> M["设置TRG(explain)"]
H --> N["设置TRG(fullstatus)"]
I --> O["添加到patternlist"]
J --> P["继续执行"]
K --> P
L --> P
M --> P
N --> P
O --> P
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L820-L880)

### 并发作业控制

系统默认根据CPU核心数自动计算最优的并发作业数：

```mermaid
graph TB
A["guess_number_of_cores()"] --> B{"检测平台"}
B --> |Windows| C["读取NUMBER_OF_PROCESSORS"]
B --> |macOS| D["执行sysctl -n hw.logicalcpu"]
B --> |Linux| E["执行nproc"]
C --> F["返回核心数"]
D --> F
E --> F
F --> G["default_njob()"]
G --> H{"核心数 <= 2?"}
H --> |是| I["nHelper = 1"]
H --> |否| J["nHelper = int(core * 0.5)"]
I --> K["返回nHelper"]
J --> K
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L150-L180)

**节来源**
- [testrunner.tcl](file://test/testrunner.tcl#L220-L242)
- [testrunner.tcl](file://test/testrunner.tcl#L150-L180)

## 预览和调试选项

### --dryrun 选项：安全预览测试行为

--dryrun选项允许用户在不实际执行任何测试的情况下预览testrunner.tcl将要执行的操作。

#### 工作原理

当启用--dryrun时，testrunner.tcl会：
1. 构建完整的测试集但不执行
2. 将所有计划执行的shell命令写入testrunner.log文件
3. 不创建或修改任何测试目录
4. 不启动任何子进程

#### 使用场景

- **构建验证**：确认测试配置正确但不实际运行
- **CI/CD集成**：在部署前验证测试计划
- **性能分析**：评估测试执行时间而不浪费资源
- **权限检查**：验证所需文件和目录的访问权限

#### 命令示例

```bash
# 预览mdevtest测试的完整流程
tclsh test/testrunner.tcl --dryrun mdevtest

# 预览特定配置的构建过程
tclsh test/testrunner.tcl --dryrun --config Debug-One release

# 结合其他选项进行综合预览
tclsh test/testrunner.tcl --dryrun --jobs 4 release
```

### --explain 选项：人类可读的测试计划

--explain选项提供详细的测试执行计划，以人类可读的格式输出。

#### 输出内容

```mermaid
graph LR
A["--explain输出"] --> B["构建任务"]
A --> C["测试任务"]
A --> D["依赖关系"]
B --> B1["配置名称"]
B --> B2["目标文件"]
B --> B3["构建命令"]
C --> C1["测试类型"]
C --> C2["测试名称"]
C --> C3["执行条件"]
D --> D1["前置任务"]
D --> D2["优先级"]
D --> D3["依赖链"]
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L1803-L1841)

#### 使用场景

- **学习测试结构**：理解复杂测试套件的组织方式
- **调试配置问题**：识别配置错误或缺失的测试
- **文档生成**：为测试文档提供自动化内容
- **团队培训**：帮助新成员了解测试架构

#### 命令示例

```bash
# 显示mdevtest的详细测试计划
tclsh test/testrunner.tcl --explain mdevtest

# 显示特定配置的测试详情
tclsh test/testrunner.tcl --explain --config All-Debug release

# 结合模式匹配过滤输出
tclsh test/testrunner.tcl --explain release fts5*
```

**节来源**
- [testrunner.tcl](file://test/testrunner.tcl#L820-L880)
- [testrunner.md](file://doc/testrunner.md#L336-L373)

## 构建控制选项

### --buildonly 选项：独立构建验证

--buildonly选项专注于构建过程，跳过所有测试执行，仅验证二进制文件的正确性。

#### 实现机制

```mermaid
sequenceDiagram
participant User as 用户
participant TR as testrunner.tcl
participant Build as 构建系统
participant Log as 日志文件
User->>TR : --buildonly release
TR->>TR : 设置TRG(buildonly)=1
TR->>Build : 执行构建任务
Build->>Build : 编译testfixture
Build->>Build : 创建测试二进制文件
TR->>Log : 记录构建过程
TR->>User : 返回构建结果
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L1803-L1841)

#### 使用场景

- **编译器兼容性测试**：验证不同编译器的兼容性
- **依赖关系验证**：确保所有必需库都可用
- **交叉编译测试**：验证目标平台的构建能力
- **持续集成**：在测试前确保构建成功

#### 命令示例

```bash
# 构建release测试所需的所有二进制文件
tclsh test/testrunner.tcl --buildonly release

# 仅构建特定配置
tclsh test/testrunner.tcl --buildonly --config All-Debug release

# 结合ZIPVFS进行扩展构建
tclsh test/testrunner.tcl --buildonly --zipvfs /path/to/zipvfs release

# 验证外部模糊测试数据库
tclsh test/testrunner.tcl --buildonly --fuzzdb /path/to/fuzzdb.db release
```

**节来源**
- [testrunner.tcl](file://test/testrunner.tcl#L220-L242)
- [testrunner.md](file://doc/testrunner.md#L336-L373)

## 动态资源管理

### njob 命令：实时调整并发作业数

njob命令允许在测试运行过程中动态调整并发作业数，以优化资源利用率和响应速度。

#### 命令语法和功能

```mermaid
flowchart TD
A["njob命令"] --> B{"参数数量"}
B --> |1个参数| C["查询当前作业数"]
B --> |2个参数| D["设置新作业数"]
D --> E{"参数验证"}
E --> |有效整数| F["更新数据库配置"]
E --> |无效| G["报错退出"]
F --> H["REPLACE INTO config"]
H --> I["重启作业调度"]
C --> J["从数据库读取"]
J --> K["输出当前值"]
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L418-L461)

#### 资源优化策略

| 场景 | 推荐作业数 | 调整原因 |
|------|------------|----------|
| 内存受限环境 | CPU核心数×0.5 | 减少内存占用 |
| 磁盘I/O密集 | CPU核心数×0.3 | 避免磁盘瓶颈 |
| 网络延迟高 | CPU核心数×0.7 | 平衡网络和计算 |
| 测试稳定性优先 | CPU核心数×0.2 | 降低资源竞争 |
| 最大吞吐量 | CPU核心数 | 充分利用硬件 |

#### 使用示例

```bash
# 查询当前并发作业数
./testfixture test/testrunner.tcl njob

# 动态增加到8个作业
./testfixture test/testrunner.tcl njob 8

# 在资源紧张时减少到2个作业
./testfixture test/testrunner.tcl njob 2

# 在负载较低时最大化并发
./testfixture test/testrunner.tcl njob 16
```

### 自适应作业调度算法

testrunner.tcl采用智能的作业调度算法来优化测试执行：

```mermaid
graph TB
A["作业调度器"] --> B{"作业优先级"}
B --> |奇数作业| C["ASC排序"]
B --> |偶数作业| D["DESC排序"]
C --> E["低优先级先执行"]
D --> F["高优先级先执行"]
E --> G["平衡负载"]
F --> G
G --> H["资源监控"]
H --> I{"资源压力"}
I --> |高| J["暂停新作业"]
I --> |正常| K["继续调度"]
J --> L["等待资源释放"]
K --> M["启动作业"]
L --> H
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L961-L1038)

**节来源**
- [testrunner.tcl](file://test/testrunner.tcl#L418-L461)
- [testrunner.tcl](file://test/testrunner.tcl#L1713-L1761)

## 状态监控和辅助命令

### --status 选项：全屏状态显示

--status选项使用VT100转义序列提供实时的全屏状态监控，类似于`watch test/testrunner status`的效果。

#### VT100转义序列实现

```mermaid
sequenceDiagram
participant Status as status命令
participant DB as testrunner.db
participant Terminal as 终端
participant User as 用户
Status->>DB : 查询作业状态
DB-->>Status : 返回状态数据
Status->>Status : 格式化输出
Status->>Terminal : 发送"\033[H" 清屏
Status->>Terminal : 发送状态信息
Status->>Terminal : 发送"\033[J" 清除剩余行
loop 每隔N秒
Status->>DB : 重新查询
DB-->>Status : 更新状态
Status->>Terminal : 更新显示
end
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L620-L680)

#### 状态信息层次结构

```mermaid
graph TD
A["状态报告"] --> B["基本信息"]
A --> C["进度统计"]
A --> D["作业状态"]
A --> E["错误信息"]
B --> B1["命令行参数"]
B --> B2["总耗时"]
B --> B3["完成作业数"]
C --> C1["已完成工作量"]
C --> C2["预计剩余时间"]
C --> C3["错误总数"]
C --> C4["测试总数"]
D --> D1["运行中作业"]
D --> D2["就绪作业"]
D --> D3["失败作业"]
D --> D4["被跳过的作业"]
E --> E1["最近失败列表"]
E --> E2["被跳过的作业数"]
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L620-L680)

#### 使用场景和参数

| 参数 | 功能 | 使用场景 |
|------|------|----------|
| `-d N` | 每N秒刷新一次 | 实时监控测试进度 |
| `--cls` | 启用全屏清除 | 避免屏幕混乱 |
| 无参数 | 单次显示 | 快速查看当前状态 |

#### 命令示例

```bash
# 实时监控测试状态（每2秒刷新）
tclsh test/testrunner.tcl status -d 2

# 全屏状态显示（支持VT100终端）
tclsh test/testrunner.tcl status --cls

# 结合延迟参数进行长时间监控
tclsh test/testrunner.tcl status -d 5 --cls

# 单次状态快照
tclsh test/testrunner.tcl status
```

### halt 命令：优雅中断测试

halt命令用于优雅地中断正在运行的测试，标记所有待执行作业为"halt"状态。

#### 中断机制

```mermaid
sequenceDiagram
participant User as 用户
participant TR as testrunner.tcl
participant DB as 数据库
participant Jobs as 作业系统
User->>TR : halt命令
TR->>DB : UPDATE jobs SET state='halt'
DB-->>TR : 确认更新
TR->>Jobs : 停止新作业启动
Jobs-->>TR : 返回停止状态
TR->>User : 退出命令
Note over Jobs : 当前运行的作业将继续完成
Note over Jobs : 新的作业不会被调度
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L440-L461)

#### 应用场景

- **资源回收**：在系统资源不足时中断测试
- **紧急修复**：发现严重问题时立即停止
- **维护操作**：在进行系统维护时安全停止
- **测试取消**：在不需要继续执行时优雅终止

### errors 命令：详细错误分析

errors命令提供详细的测试失败分析，支持多种输出模式和过滤选项。

#### 错误输出模式

```mermaid
flowchart TD
A["errors命令"] --> B{"输出模式"}
B --> |默认| C["摘要模式"]
B --> |-v/--verbose| D["详细模式"]
B --> |-s/--summary| E["总结模式"]
C --> F["显示失败作业名"]
D --> G["显示完整输出"]
E --> H["仅显示失败计数"]
F --> I["过滤模式匹配"]
G --> I
H --> I
I --> J["应用GLOB模式过滤"]
J --> K["输出结果"]
```

**图表来源**
- [testrunner.tcl](file://test/testrunner.tcl#L800-L850)

#### 错误分析功能

| 功能 | 描述 | 使用场景 |
|------|------|----------|
| 失败作业列表 | 显示所有失败的测试 | 快速定位问题范围 |
| 完整输出 | 显示测试的全部日志 | 深度调试分析 |
| 错误摘要 | 统计错误总数和测试数 | 性能指标分析 |
| 模式过滤 | 支持GLOB模式匹配 | 集中分析特定问题 |

#### 命令示例

```bash
# 显示所有失败测试的摘要
tclsh test/testrunner.tcl errors

# 显示详细错误信息
tclsh test/testrunner.tcl errors -v

# 仅显示错误统计
tclsh test/testrunner.tcl errors -s

# 分析特定类型的错误
tclsh test/testrunner.tcl errors "fts5*"

# 结合模式过滤显示详细信息
tclsh test/testrunner.tcl errors -v "corrupt*"
```

**节来源**
- [testrunner.tcl](file://test/testrunner.tcl#L620-L700)
- [testrunner.tcl](file://test/testrunner.tcl#L440-L461)
- [testrunner.tcl](file://test/testrunner.tcl#L800-L850)

## 使用场景和最佳实践

### 开发阶段的最佳实践

#### 快速迭代开发

```bash
# 1. 预览测试计划（不执行）
tclsh test/testrunner.tcl --dryrun --explain mdevtest

# 2. 快速验证构建（不运行测试）
tclsh test/testrunner.tcl --buildonly mdevtest

# 3. 运行快速测试套件
./testfixture test/testrunner.tcl veryquick
```

#### 调试和问题排查

```bash
# 1. 监控测试进度
tclsh test/testrunner.tcl status -d 2

# 2. 分析失败原因
tclsh test/testrunner.tcl errors -v

# 3. 中断异常测试
tclsh test/testrunner.tcl halt

# 4. 查看作业状态
tclsh test/testrunner.tcl joblist
```

### CI/CD集成策略

#### 持续集成流水线

```mermaid
graph LR
A["代码提交"] --> B["构建验证"]
B --> C["--buildonly检查"]
C --> D{"构建是否成功?"}
D --> |是| E["运行快速测试"]
D --> |否| F["构建失败"]
E --> G["--dryrun预览"]
G --> H["运行测试"]
H --> I["收集结果"]
I --> J["生成报告"]
F --> K["通知开发者"]
J --> L["部署决策"]
```

#### 环境适配策略

| 环境类型 | 推荐配置 | 原因 |
|----------|----------|------|
| 开发机 | 默认并发数 | 快速反馈 |
| CI服务器 | CPU核心数×0.7 | 避免资源竞争 |
| 虚拟机 | CPU核心数×0.5 | 资源限制 |
| 容器环境 | CPU核心数×0.3 | 资源隔离 |
| 生产测试 | CPU核心数×0.2 | 稳定性优先 |

### 性能优化建议

#### 资源利用率优化

```bash
# 根据系统负载动态调整
if [free_memory < 2GB]; then
    ./testfixture test/testrunner.tcl njob 2
else
    ./testfixture test/testrunner.tcl njob 8
fi

# 监控磁盘I/O进行调整
if [disk_iops > threshold]; then
    ./testfixture test/testrunner.tcl njob 4
fi
```

#### 测试策略组合

```bash
# 开发阶段：快速验证
tclsh test/testrunner.tcl --dryrun --explain veryquick

# 测试阶段：全面验证
tclsh test/testrunner.tcl --buildonly release

# 生产阶段：稳定运行
./testfixture test/testrunner.tcl release
```

## 故障排除指南

### 常见问题和解决方案

#### VT100转义序列问题

**问题描述**：在Windows系统上--status选项显示异常

**解决方案**：
```bash
# 使用替代方案
tclsh test/testrunner.tcl status -d 2

# 或者使用非VT100版本
tclsh test/testrunner.tcl status --cls
```

#### 并发作业数过高

**症状**：系统响应缓慢，测试超时

**诊断步骤**：
```bash
# 检查当前作业数
./testfixture test/testrunner.tcl njob

# 降低并发数
./testfixture test/testrunner.tcl njob 2

# 监控系统资源
tclsh test/testrunner.tcl status -d 5
```

#### 数据库锁定问题

**问题描述**：testrunner.db被锁定无法访问

**解决方法**：
```bash
# 检查是否有残留进程
ps aux | grep testrunner

# 强制终止相关进程
kill -9 <PID>

# 删除损坏的数据库文件
rm testrunner.db

# 重新开始测试
./testfixture test/testrunner.tcl veryquick
```

### 调试技巧

#### 日志分析

```bash
# 查看详细构建日志
cat testrunner.log | grep "BUILD"

# 分析测试失败
cat testrunner.log | grep "FAILED"

# 监控实时输出
tail -f testrunner.log
```

#### 状态监控

```bash
# 实时监控测试进度
watch -n 2 tclsh test/testrunner.tcl status

# 详细状态信息
tclsh test/testrunner.tcl status -d 1 --cls

# 作业状态检查
tclsh test/testrunner.tcl joblist
```

### 性能调优

#### 系统资源监控

```bash
# CPU使用率监控
top -p $(pgrep -f testrunner)

# 内存使用监控
ps aux | grep testrunner

# 磁盘I/O监控
iotop -p $(pgrep -f testrunner)
```

#### 测试执行优化

```bash
# 根据系统特性调整
case "$(uname -s)" in
    Darwin)
        # macOS优化
        export NOJOB=$(sysctl -n hw.ncpu)
        ;;
    Linux)
        # Linux优化
        export NOJOB=$(nproc)
        ;;
    *)
        # 默认值
        export NOJOB=4
        ;;
esac

# 应用优化配置
./testfixture test/testrunner.tcl --jobs $NOJOB release
```

通过合理使用这些高级控制选项，开发者可以显著提高测试效率，更好地理解和调试测试过程，并在不同环境中优化测试性能。这些工具不仅适用于日常开发，也是持续集成和生产部署的重要组成部分。