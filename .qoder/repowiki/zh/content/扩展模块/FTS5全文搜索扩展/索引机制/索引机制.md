# FTS5倒排索引机制深度解析

<cite>
**本文档引用的文件**
- [fts5_index.c](file://ext/fts5/fts5_index.c)
- [fts5Int.h](file://ext/fts5/fts5Int.h)
- [fts5_varint.c](file://ext/fts5/fts5_varint.c)
- [fts5_storage.c](file://ext/fts5/fts5_storage.c)
- [fts5_main.c](file://ext/fts5/fts5_main.c)
- [fts5_vocab.c](file://ext/fts5/fts5_vocab.c)
</cite>

## 目录
1. [概述](#概述)
2. [索引架构设计](#索引架构设计)
3. [段（Segment）组织结构](#段segment组织结构)
4. [层级合并策略](#层级合并策略)
5. [行ID编码与位置列表](#行id编码与位置列表)
6. [索引维护流程](#索引维护流程)
7. [后台合并操作](#后台合并操作)
8. [索引压缩与优化](#索引压缩与优化)
9. [诊断工具与性能监控](#诊断工具与性能监控)
10. [性能优化建议](#性能优化建议)

## 概述

FTS5（全文搜索第5版）是SQLite的高级全文搜索引擎，采用倒排索引技术实现高效的文本检索。其核心设计理念是通过分层的段组织结构、智能的合并策略和紧凑的数据编码方式，在保证查询性能的同时最小化存储空间占用。

### 核心特性

- **分层B树结构**：采用多级段组织，支持大规模数据集的高效管理
- **增量合并**：自动执行后台合并操作，保持索引性能
- **变长整数编码**：使用varint编码减少存储开销
- **文档列表索引**：为大型文档列表提供快速定位机制
- **内容无关删除**：支持高效的删除操作而不影响查询性能

## 索引架构设计

FTS5索引采用分层的B树结构，将索引数据组织成多个层次，每个层次包含若干段（segment）。

```mermaid
graph TB
subgraph "FTS5索引结构"
A[结构记录<br/>Structure Record] --> B[级别0<br/>Level 0]
A --> C[级别1<br/>Level 1]
A --> D[级别N<br/>Level N]
B --> E[段1<br/>Segment 1]
B --> F[段2<br/>Segment 2]
B --> G[段N<br/>Segment N]
E --> H[叶子页面<br/>Leaf Pages]
E --> I[文档列表索引<br/>Doclist Index]
H --> J[术语/文档列表<br/>Term/Doclist]
I --> K[页面定位<br/>Page Location]
end
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L45-L100)

### 数据表结构

FTS5使用三个主要的shadow表来存储索引数据：

| 表名 | 用途 | 存储内容 |
|------|------|----------|
| `%_data` | 主要索引数据 | 结构记录、段叶子、文档列表索引、墓碑哈希页 |
| `%_idx` | 索引辅助表 | 段ID、术语、页面号的映射关系 |
| `%_config` | 配置信息 | 版本号、配置参数等 |

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L100-L200)

## 段（Segment）组织结构

### 段标识符系统

每个段都有唯一的16位段标识符（segid），用于在索引中唯一标识各个段。

```mermaid
classDiagram
class Fts5StructureSegment {
+int iSegid
+int pgnoFirst
+int pgnoLast
+u64 iOrigin1
+u64 iOrigin2
+int nPgTombstone
+u64 nEntryTombstone
+u64 nEntry
}
class Fts5StructureLevel {
+int nMerge
+int nSeg
+Fts5StructureSegment[] aSeg
}
class Fts5Structure {
+int nRef
+u64 nWriteCounter
+u64 nOriginCntr
+int nSegment
+int nLevel
+Fts5StructureLevel[] aLevel
}
Fts5Structure --> Fts5StructureLevel : "包含"
Fts5StructureLevel --> Fts5StructureSegment : "包含"
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L350-L400)

### 叶子页面格式

段的叶子页面采用固定大小的页面结构，通常为1000字节：

```mermaid
graph LR
subgraph "叶子页面布局"
A[页面头部<br/>4字节] --> B[第一个行ID偏移<br/>2字节]
B --> C[页面尾部偏移<br/>2字节]
C --> D[页面数据<br/>剩余部分]
D --> E[术语列表<br/>Term List]
D --> F[文档列表<br/>Doclist]
D --> G[页面索引<br/>Page Index]
end
```

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L150-L250)

## 层级合并策略

FTS5采用分层的合并策略，将新插入的数据首先写入低级别的段，然后通过增量合并逐步向上移动。

### 合并触发条件

```mermaid
flowchart TD
A[开始合并检查] --> B{是否有正在进行的合并?}
B --> |是| C[继续当前合并]
B --> |否| D{级别中有足够的段?}
D --> |否| E[查找删除合并候选]
D --> |是| F[选择最佳合并级别]
F --> G{级别满足合并条件?}
G --> |否| E
G --> |是| H[执行合并操作]
E --> I{找到删除合并?}
I --> |是| H
I --> |否| J[无合并可执行]
H --> K[更新结构记录]
K --> L[清理输入段]
L --> M[完成合并]
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L4944-L5000)

### 合并工作单元

FTS5定义了两个重要的工作单位常量：

| 常量 | 值 | 用途 |
|------|-----|------|
| `FTS5_WORK_UNIT` | 64 | 单个工作单元的叶子页面数量 |
| `FTS5_OPT_WORK_UNIT` | 1000 | 优化操作的工作单元大小 |

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L45-L47)

## 行ID编码与位置列表

### Varint编码机制

FTS5使用变长整数（varint）编码来压缩存储空间，特别是对于频繁出现的小数值。

```mermaid
graph LR
subgraph "Varint编码规则"
A[值范围] --> B[1字节<br/>0-127]
A --> C[2字节<br/>128-16383]
A --> D[3字节<br/>16384-2097151]
A --> E[4字节及以上<br/>更大值]
end
subgraph "编码格式"
F[最高位为1] --> G[后续字节继续编码]
H[最高位为0] --> I[结束编码]
end
```

**图表来源**
- [fts5_varint.c](file://ext/fts5/fts5_varint.c#L20-L100)

### 文档列表格式

文档列表（doclist）存储特定术语在所有文档中的出现位置：

```mermaid
sequenceDiagram
participant T as 术语
participant R as 行ID
participant P as 位置列表
T->>R : 第一行ID (绝对值)
R->>P : 位置列表1
R->>R : 行ID增量 (相对值)
R->>P : 位置列表2
R->>R : 行ID增量 (相对值)
R->>P : 位置列表3
Note over T,P : 重复直到所有行ID处理完毕
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L200-L300)

### 位置列表存储

位置列表记录术语在文档中的具体位置信息：

| 字段 | 类型 | 描述 |
|------|------|------|
| 大小字段 | varint | 位置列表大小（字节数×2） |
| 列号 | varint | 所在列的编号 |
| 偏移量 | varint | 在该列中的偏移位置 |

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L120-L180)

## 索引维护流程

### 文档插入流程

```mermaid
flowchart TD
A[开始文档插入] --> B[调用sqlite3Fts5IndexBeginWrite]
B --> C[设置文档ID和删除标志]
C --> D[对每个令牌调用sqlite3Fts5IndexWrite]
D --> E[将令牌添加到内存哈希表]
E --> F{哈希表满或达到刷新阈值?}
F --> |否| G[继续处理下一个令牌]
F --> |是| H[调用sqlite3Fts5IndexSync]
G --> D
H --> I[将哈希表内容写入磁盘]
I --> J[清空哈希表]
J --> K[完成插入]
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L6900-L7000)

### 文档更新机制

FTS5支持两种更新模式：

1. **内容相关删除**：删除旧文档内容，插入新内容
2. **内容无关删除**：仅标记删除，不实际删除内容

```mermaid
graph TB
subgraph "内容相关删除"
A[删除旧文档] --> B[扫描所有令牌]
B --> C[从索引中移除]
C --> D[插入新文档] --> E[添加新令牌]
end
subgraph "内容无关删除"
F[标记删除] --> G[添加墓碑条目]
G --> H[保留文档内容]
H --> I[查询时跳过墓碑]
end
```

**图表来源**
- [fts5_storage.c](file://ext/fts5/fts5_storage.c#L600-L700)

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L6900-L7100)

## 后台合并操作

### 自动合并机制

FTS5实现了智能的自动合并机制，根据写入计数器动态触发合并操作：

```mermaid
sequenceDiagram
participant W as 写入操作
participant C as 写入计数器
participant M as 自动合并器
participant L as 合并级别
W->>C : 更新写入计数器
C->>C : 计算需要的工作量
C->>M : 触发合并请求
M->>L : 选择最佳合并级别
L->>L : 执行段合并
L->>W : 返回合并结果
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L5000-L5050)

### 合并参数配置

| 参数 | 默认值 | 描述 |
|------|--------|------|
| `nAutomerge` | 动态计算 | 自动合并的最小段数 |
| `nCrisisMerge` | 2000 | 危机合并的段数阈值 |
| `nDeleteMerge` | 0 | 删除合并的百分比阈值 |

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L4950-L5050)

## 索引压缩与优化

### 文档列表索引

为了加速大型文档列表的查找，FTS5引入了文档列表索引（doclist index）：

```mermaid
graph TB
subgraph "文档列表索引结构"
A[根节点] --> B[内部节点1]
A --> C[内部节点2]
B --> D[叶子节点1]
B --> E[叶子节点2]
C --> F[叶子节点3]
C --> G[叶子节点4]
D --> H[页面1: 第一行ID]
E --> I[页面2: 第一行ID]
F --> J[页面3: 第一行ID]
G --> K[页面4: 第一行ID]
end
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L300-L400)

### 压缩阈值

FTS5定义了最小文档列表索引大小阈值：

| 常量 | 值 | 用途 |
|------|-----|------|
| `FTS5_MIN_DLIDX_SIZE` | 4 | 添加文档列表索引的最小空页面数 |

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L48-L49)

### 优化操作

FTS5提供了多种优化操作来提升索引性能：

```mermaid
flowchart TD
A[开始优化] --> B[读取当前结构]
B --> C[构建新的优化结构]
C --> D[按级别执行合并]
D --> E[写入新结构]
E --> F[释放旧结构]
F --> G[完成优化]
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L5894-L5952)

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L5894-L5952)

## 诊断工具与性能监控

### 完整性检查

FTS5提供了强大的完整性检查功能，可以验证索引的一致性和正确性：

```mermaid
flowchart TD
A[开始完整性检查] --> B[读取索引结构]
B --> C[计算校验和]
C --> D[扫描索引内容]
D --> E[重新计算校验和]
E --> F{校验和匹配?}
F --> |是| G[检查通过]
F --> |否| H[报告错误]
```

**图表来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L8606-L8650)

### PRAGMA命令支持

FTS5支持多个PRAGMA命令用于索引诊断：

| PRAGMA命令 | 功能描述 |
|------------|----------|
| `PRAGMA fts5_index_check` | 检查索引完整性 |
| `PRAGMA fts5_index_size` | 获取索引大小信息 |
| `PRAGMA fts5_index_stats` | 显示索引统计信息 |

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L8606-L8650)

### 性能监控指标

FTS5跟踪以下关键性能指标：

| 指标名称 | 描述 | 监控方法 |
|----------|------|----------|
| 写入计数器 | 已写入的叶子页面总数 | `nWriteCounter` |
| 段数量 | 当前索引中的段总数 | `nSegment` |
| 合并次数 | 已执行的合并操作次数 | 结构记录中的计数器 |

**节来源**
- [fts5_index.c](file://ext/fts5/fts5_index.c#L350-L400)

## 性能优化建议

### 写入放大问题

FTS5的写入放大主要来源于以下几个方面：

1. **频繁的合并操作**：大量小段的合并会产生额外的写入开销
2. **文档列表索引**：大型文档列表需要额外的索引页面
3. **墓碑条目**：内容无关删除会增加墓碑条目的存储需求

### 优化策略

#### 1. 调整合并参数

```sql
-- 调整自动合并参数
INSERT INTO t1(t1, rank) VALUES('automerge', 16);

-- 设置危机合并阈值
INSERT INTO t1(t1, rank) VALUES('crisismerge', 1000);
```

#### 2. 使用内容无关删除

对于频繁更新的场景，启用内容无关删除可以显著减少写入放大：

```sql
CREATE VIRTUAL TABLE documents USING fts5(
    content, 
    contentless_delete=1
);
```

#### 3. 优化页面大小

根据数据特征调整页面大小：

```sql
-- 设置页面大小为4KB
INSERT INTO t1(t1, rank) VALUES('pgsz', 4096);
```

#### 4. 定期优化索引

定期执行索引优化操作：

```sql
-- 执行优化
INSERT INTO documents(documents) VALUES('optimize');

-- 手动合并
INSERT INTO documents(documents) VALUES('merge', 10);
```

### 监控建议

1. **定期检查索引大小**：监控索引增长趋势
2. **关注合并频率**：过多的合并可能影响性能
3. **观察写入计数器**：了解索引的活跃程度
4. **检查完整性**：定期运行完整性检查

通过合理配置这些参数和监控指标，可以在查询性能和写入效率之间找到最佳平衡点。